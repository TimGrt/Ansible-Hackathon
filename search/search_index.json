{"config":{"lang":["en"],"separator":"[\\s]","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>Herzlich Willkommen zum Ansible Hackathon Vol.1!</p> <p>Wir wollen mit euch Use-Cases bearbeiten, welche wir auch h\u00e4ufig bei unseren Kunden antreffen und uns dabei insbesondere auf die weniger h\u00e4ufig verwendeten Features der Ansible Automation Platform fokussieren.</p> <p>Der Hackathon steht im Zeichen eines freundlichen Wettkampfs, zwei Teams treten gegeneinander an und bearbeiten jeweils einen eigenen Use-Case. Letztlich arbeiten aber beide Teams auf ein gemeinsames Ziel hin!</p> <p> </p> <p>Diese Dokumentation dient zum einen der Beschreibung der beiden Use-Cases, als auch zur Dokumentation der Umsetzung.</p>"},{"location":"demo_environment/","title":"Demo Umgebung","text":"<p>Hier findet ihr die Links zur Demo-Umgebung:</p> <p>Warning</p> <p>ADD LINKS HERE AFTER DEPLOYMENT!</p>"},{"location":"demo_environment/#aap-automatisierung","title":"AAP Automatisierung","text":"<p>Zur Automatisierung der Ansible Automation Platform (Controller, EDA, Automation Hub) sind die folgenden Links hilfreich:</p> <ul> <li>infra.aap_configuration auf Galaxy</li> <li>Github Repository f\u00fcr infra.aap_configuration Collection</li> <li>Beispiel Template f\u00fcr AAP Configuration as Code</li> </ul> <p>Tip</p> <p>Verwendet die Certified Collection aus dem Red Hat Automation Hub!</p>"},{"location":"usecase_one/usecase_one_description/","title":"EDA mit Netbox, AAP und Openshift","text":""},{"location":"usecase_one/usecase_one_description/#ubersicht","title":"\u00dcbersicht","text":"<p>In diesem Use-Case soll mit Event-Driven Ansible auf Events in der Netbox reagiert werden, bei Anlage eines VM Objekts soll automatisiert eine virtuelle Maschine \u00fcber OpenShift Virtualization im OpenShift Cluster erstellt werden. Folgende Tools sollen hier bei zum Einsatz kommen:</p> <ul> <li>Single Source of Truth Netbox</li> <li>SCM nach Wahl</li> <li>Ansible Automation Platform</li> <li>OpenShift / OpenShift Virtualization</li> <li>Event-Driven Ansible</li> <li>Ansible Navigator</li> <li>Ansible Builder v3</li> <li>Execution Environment (default oder custom)</li> </ul> <p>Ziel</p> <p>Die Playbooks befinden sich in einem SCM, der Usecase ist vollautomatisiert (auch alle Konfigurationen in der AAP) und nach Doku Vorgaben zu beschreiben.</p>"},{"location":"usecase_one/usecase_one_description/#vorgehen","title":"Vorgehen","text":"<ul> <li> <p> Step 1     Es sollen mehrere simple Device Objekte, ohne viel Individualisierung, in der Netbox angelegt werden. Die Anlage, der zu erstellende Objekte, kann durch ein Playbook mit Hilfe der Netbox Collection erfolgen. Zur Orientierung gibt es auf Github vordefinierte Device Types GitHub</p> <p>Tip</p> <p>Man kann alle Objektdaten des Inventory Plugin \u00fcber ansible-inventory anzeigen.</p> </li> <li> <p> Step 2     \u00dcber einen Webhook, aus der Netbox, soll ein Playbook f\u00fcr die Erstellung eines Containers oder VM getriggert werden.</p> </li> <li> <p> Step 3     Event-Driven Automation Rulebook erstellen und auf ein beliebiges Event h\u00f6ren z.B. Prozess oder \u00c4nderung des Netboxobjekt. Durch das getriggerte Event wird ein Playbook (lokal) oder ein Job/Workflow-Template in der AAP ausgef\u00fchrt werden. Alles soll nach den Tests \u00fcber die AAP 2.5 funktionieren.</p> <p>Success</p> <p>Hier m\u00fcsst ihr mit dem Team von Use-Case 2 zusammenarbeiten, sie sollen auf der von euch erstellten virtuellen Maschine Konfigurationen durchf\u00fchren! Erstellt ein gemeinsamen Workflow, das andere Team erstellt unter anderem ein dynamisches Netbox-Inventory.</p> </li> </ul>"},{"location":"usecase_one/usecase_one_description/#links","title":"Links","text":"<p>Einige hilfreiche Tipps findet ihr hier:</p> <ul> <li>netbox-community Devicetype-library documentation</li> <li>Ansible Builder documentation</li> <li>Ansible Navigator documentation</li> <li>Event-Driven Ansible documentation</li> </ul>"},{"location":"usecase_one/usecase_one_documentation/","title":"Use-Case 1 Dokumentation","text":"<p>TODO</p> <p>Hier soll eure Dokumentation f\u00fcr den ersten Use-Case entstehen! Erstellt einen Fork des Projekts (ihr ben\u00f6tigt einen Github Account), f\u00fcgt eure Dokumentation in der passenden Datei <code>docs/usecase_one/usecase_one_documentation.md</code> hinzu und erstellt anschlie\u00dfend einen Pull Request gegen das originale Repository.</p> <p>Die Dokumentation ist einfach Markdown, im verwendeten MkDocs Material Theme k\u00f6nnt ihr noch einige zus\u00e4tzliche Dinge hinterlegen. Schaut in die Doku oder auch in den Contributing Guide dieses Repositories.</p> <p>Generell sollte die Dokumentation die folgenden Punkte enthalten:</p> <pre><code># Title\n\nBrief description of the role, what it does and what not.\n\n## Architecture\n\nHere is a brief overview of the architecture\n\n## Challenges and ToDo's\n\nIf anything is missing, add a short description here.\n\n## Installation guide\n\nDescription of the installation\n\n## Requirements\n\nTechnical requirements, e.g. necessary packages/rpms, own modules or plugins.\n\n## Dependencies\n\nThis role expects to run **after** the following roles:\n* repository\n* networking\n* common\n* software\n\n## Tool definition 1\n\nDescription of the first tool used\n\n## Tool definition 2\n\nDescription of the second tool used\n\n## Tool definition 3\n\nDescription of the third tool used\n\n## Ansible playbook\n\n### Role Variables\n\nThe role uses the following variables:\n\n| Variable Name | Type    | Default Value | Description            |\n| ------------- | ------- | ------------- | ---------------------- |\n| example       | Boolean | false         | Brief description      |\n\n### Tags\n\nThe role can be executed with the following tags:\n* install\n* configure\n* service\n\n### Example Playbook\n\nUse the role in a playbook like this (after running plays/roles from dependencies section):\n```yaml\n- name: Execute role\n  hosts: example_servers\n  become: true\n  roles:\n    - example_role\n```\n\n## Authors\n\nTim Gr\u00fctzmacher - &lt;tim.gruetzmacher@computacenter.com&gt;\nJonathan Schmidt - &lt;jonathan.schmidt@computacenter.com&gt;\n</code></pre>"},{"location":"usecase_two/usecase_two_description/","title":"Netbox-Inventory, Molecule und Ansible-Sign","text":""},{"location":"usecase_two/usecase_two_description/#ubersicht","title":"\u00dcbersicht","text":"<p>In diesem Use-Case soll auf virtuellen Maschinen ein Webserver mit der Dokumentation des Hackathons konfiguriert werden. Das Inventory soll dabei dynamisch aus der Netbox bezogen werden. Euer Ansible/Repository-Content soll mit Ansible-Sign signiert sein. Folgende Tools sollen hier bei zum Einsatz kommen:</p> <ul> <li>Single Source of Truth Netbox</li> <li>SCM nach Wahl</li> <li>Ansible Automation Platform</li> <li>Ansible Navigator</li> <li>Ansible-Sign</li> <li>Ansible Builder v3</li> <li>Execution Environment (default oder custom)</li> </ul> <p>Ziel</p> <p>Die Playbooks befinden sich in einem SCM, der Usecase ist vollautomatisiert (auch alle Konfigurationen in der AAP) und nach Doku Vorgaben zu beschreiben.</p>"},{"location":"usecase_two/usecase_two_description/#vorgehen","title":"Vorgehen","text":"<ul> <li> <p> Step 1     Erstellt ein dynamisches Inventory mit Nexbox als Quelle, alle VM-Objekte des Tenants sollen im Ansible/AAP-Inventory automatisch gesynct werden.</p> <p>Tip</p> <p>Man kann alle Objektdaten des Inventory Plugin \u00fcber ansible-inventory anzeigen.</p> </li> <li> <p> Step 2     Das Team aus Use-Case 1 erstellt VM-Instanzen in OpenShift Virtualization, auf diesen VMs sollt ihr automatisiert eine Webserver konfigurieren, welcher die Dokumentation des Projekts anzeigt. Es kann das GitHub Projekt des Hackathon verwendet werden und um die Dokumentation erweitert werden.</p> <p>Success</p> <p>Bis die VMs bereitstehen, sollt ihr euer Playbook lokal, mithilfe von Molecule entwickeln, nutzt dabei die Beschreibung aus dem Best Practice Guide. Ein passender Test-Container (UBI8 Init-Container, verh\u00e4lt sich sehr \u00e4hnlich zu RHEL8-VM) ist hier zu finden: ghcr.io/timgrt/rhel8-molecule-test-image:main</p> Tipps zum Deployment der Dokumentation <p>Die folgenden Schritte sind f\u00fcr ein RHEL8-System zu befolgen:</p> <p> Webserver-Paket <code>httpd</code> installieren  Git-Paket <code>git</code> installieren  Projekt per HTTPS klonen: <code>https://github.com/TimGrt/Ansible-Hackathon.git</code>  Notwendige Python-Version <code>python3.12</code> und Python-Paket-Manager <code>python3.12-pip</code> installieren  Python-Dependencies <code>requirements.txt</code>des Projekts installieren (passenden Paketmanager ausw\u00e4hlen!)  MkDocs Projekt bauen: <code>python3.12 -m mkdocs build --site-dir /var/www/html</code>  Webserver starten  </p> <p>Success</p> <p>Das Playbook soll nat\u00fcrlich idempotent sein!</p> </li> <li> <p> Step 3     Signiert euren Ansible/Repository-Content mit <code>ansible-sign</code>. Nur signierter Code soll in der AAP ausf\u00fchrbar sein! Alles soll nach den Tests \u00fcber die AAP 2.5 funktionieren.</p> </li> <li> <p> Step 4     Erstellt eine Pipeline (Github Actions, Gitlab Pipeline, je nach Wahl eures SCM-Backends), welche bei einem Merge in den main-Branch euren Ansible-Content automatisch mit ansible-sign signiert.</p> </li> </ul>"},{"location":"usecase_two/usecase_two_description/#links","title":"Links","text":"<p>Einige hilfreiche Tipps findet ihr hier:</p> <ul> <li>Netbox Collection</li> <li>ansible-builder</li> <li>ansible-navigator</li> <li>ansible-sign</li> </ul>"},{"location":"usecase_two/usecase_two_documentation/","title":"Use-Case 2 Dokumentation","text":"<p>TODO</p> <p>Hier soll eure Dokumentation f\u00fcr den zweiten Use-Case entstehen! Erstellt einen Fork des Projekts (ihr ben\u00f6tigt einen Github Account), f\u00fcgt eure Dokumentation in der passenden Datei <code>docs/usecase_two/usecase_two_documentation.md</code> hinzu und erstellt anschlie\u00dfend einen Pull Request gegen das originale Repository.</p> <p>Die Dokumentation ist einfach Markdown, im verwendeten MkDocs Material Theme k\u00f6nnt ihr noch einige zus\u00e4tzliche Dinge hinterlegen. Schaut in die Doku oder auch in den Contributing Guide dieses Repositories.</p> <p>Generell sollte die Dokumentation die folgenden Punkte enthalten:</p> <pre><code># Title\n\nBrief description of the role, what it does and what not.\n\n## Architecture\n\nHere is a brief overview of the architecture\n\n## Challenges and ToDo's\n\nIf anything is missing, add a short description here.\n\n## Installation guide\n\nDescription of the installation\n\n## Requirements\n\nTechnical requirements, e.g. necessary packages/rpms, own modules or plugins.\n\n## Dependencies\n\nThis role expects to run **after** the following roles:\n* repository\n* networking\n* common\n* software\n\n## Tool definition 1\n\nDescription of the first tool used\n\n## Tool definition 2\n\nDescription of the second tool used\n\n## Tool definition 3\n\nDescription of the third tool used\n\n## Ansible playbook\n\n### Role Variables\n\nThe role uses the following variables:\n\n| Variable Name | Type    | Default Value | Description            |\n| ------------- | ------- | ------------- | ---------------------- |\n| example       | Boolean | false         | Brief description      |\n\n### Tags\n\nThe role can be executed with the following tags:\n* install\n* configure\n* service\n\n### Example Playbook\n\nUse the role in a playbook like this (after running plays/roles from dependencies section):\n```yaml\n- name: Execute role\n  hosts: example_servers\n  become: true\n  roles:\n    - example_role\n```\n\n## Authors\n\nTim Gr\u00fctzmacher - &lt;tim.gruetzmacher@computacenter.com&gt;\nJonathan Schmidt - &lt;jonathan.schmidt@computacenter.com&gt;\n</code></pre>"}]}